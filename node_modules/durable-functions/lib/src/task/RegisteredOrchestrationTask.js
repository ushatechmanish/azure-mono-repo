"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisteredOrchestrationTask = void 0;
const CallSubOrchestratorAction_1 = require("../actions/CallSubOrchestratorAction");
const CallSubOrchestratorWithRetryAction_1 = require("../actions/CallSubOrchestratorWithRetryAction");
const AtomicTask_1 = require("./AtomicTask");
const RetryableTask_1 = require("./RetryableTask");
class RegisteredOrchestrationTask extends AtomicTask_1.AtomicTask {
    constructor(orchestrationName, input, instanceId) {
        super(false, new CallSubOrchestratorAction_1.CallSubOrchestratorAction(orchestrationName, instanceId, input));
        this.withRetry = (retryOptions) => {
            if (this.alreadyScheduled) {
                throw new Error("Invalid use of `.withRetry`: attempted to create a retriable task from an already scheduled task. " +
                    `A task with ID ${this.id} to call subOrchestrator ${orchestrationName} has already been scheduled. ` +
                    "Make sure to only invoke `.withRetry` on tasks that have not previously been yielded.");
            }
            const callSubOrchestratorWithRetryAction = new CallSubOrchestratorWithRetryAction_1.CallSubOrchestratorWithRetryAction(orchestrationName, retryOptions, input, instanceId);
            const backingTask = new AtomicTask_1.AtomicTask(false, callSubOrchestratorWithRetryAction);
            return new RetryableTask_1.RetryableTask(backingTask, retryOptions);
        };
    }
}
exports.RegisteredOrchestrationTask = RegisteredOrchestrationTask;
//# sourceMappingURL=RegisteredOrchestrationTask.js.map