"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallHttpWithPollingTask = void 0;
const CompoundTask_1 = require("./CompoundTask");
const _1 = require(".");
const moment = require("moment");
const CallHttpAction_1 = require("../actions/CallHttpAction");
const DurableHttpResponse_1 = require("../http/DurableHttpResponse");
class CallHttpWithPollingTask extends CompoundTask_1.CompoundTask {
    constructor(id, action, orchestrationContext, executor, defaultHttpAsyncRequestSleepTimeMillseconds) {
        super([new _1.AtomicTask(id, action)], action);
        this.orchestrationContext = orchestrationContext;
        this.executor = executor;
        this.id = id;
        this.action = action;
        this.defaultHttpAsyncRequestSleepDuration = moment.duration(defaultHttpAsyncRequestSleepTimeMillseconds, "ms");
    }
    trySetValue(child) {
        if (child.stateObj === _1.TaskState.Completed) {
            if (child.actionObj instanceof CallHttpAction_1.CallHttpAction) {
                const resultObj = child.result;
                const result = new DurableHttpResponse_1.DurableHttpResponse(resultObj.statusCode, resultObj.content, resultObj.headers);
                if (result.statusCode === 202 && result.getHeader("Location")) {
                    const retryAfterHeaderValue = result.getHeader("Retry-After");
                    const delay = retryAfterHeaderValue
                        ? moment.duration(retryAfterHeaderValue, "s")
                        : this.defaultHttpAsyncRequestSleepDuration;
                    const currentTime = this.orchestrationContext.currentUtcDateTime;
                    const timerFireTime = moment(currentTime).add(delay).toDate();
                    const timerTask = this.orchestrationContext.createTimer(timerFireTime);
                    const callHttpTask = new _1.AtomicTask(false, new CallHttpAction_1.CallHttpAction(this.action.httpRequest));
                    this.addNewChildren([timerTask, callHttpTask]);
                }
                else {
                    this.setValue(false, result);
                }
            }
        }
        else {
            if (this.firstError === undefined) {
                this.firstError = child.result;
                this.setValue(true, this.firstError);
            }
        }
    }
    addNewChildren(children) {
        children.map((child) => {
            child.parent = this;
            this.children.push(child);
            this.executor.trackOpenTask(child);
        });
    }
}
exports.CallHttpWithPollingTask = CallHttpWithPollingTask;
//# sourceMappingURL=CallHttpWithPollingTask.js.map