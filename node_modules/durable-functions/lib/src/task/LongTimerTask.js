"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LongTimerTask = void 0;
const WhenAllTask_1 = require("./WhenAllTask");
const moment = require("moment");
const DFTimerTask_1 = require("./DFTimerTask");
const CreateTimerAction_1 = require("../actions/CreateTimerAction");
class LongTimerTask extends WhenAllTask_1.WhenAllTask {
    constructor(id, action, orchestrationContext, executor, maximumTimerLength, longRunningTimerIntervalLength) {
        const maximumTimerDuration = moment.duration(maximumTimerLength);
        const longRunningTimerIntervalDuration = moment.duration(longRunningTimerIntervalLength);
        const currentTime = orchestrationContext.currentUtcDateTime;
        const finalFireTime = action.fireAt;
        const durationUntilFire = moment.duration(moment(finalFireTime).diff(currentTime));
        const nextFireTime = durationUntilFire > maximumTimerDuration
            ? moment(currentTime).add(longRunningTimerIntervalDuration).toDate()
            : finalFireTime;
        const nextTimerAction = new CreateTimerAction_1.CreateTimerAction(nextFireTime);
        const nextTimerTask = new DFTimerTask_1.DFTimerTask(false, nextTimerAction);
        super([nextTimerTask], action);
        this.id = id;
        this.action = action;
        this.orchestrationContext = orchestrationContext;
        this.executor = executor;
        this.maximumTimerDuration = maximumTimerDuration;
        this.longRunningTimerIntervalDuration = longRunningTimerIntervalDuration;
    }
    get isCanceled() {
        return this.action.isCanceled;
    }
    cancel() {
        if (this.hasResult) {
            throw Error("Cannot cancel a completed task.");
        }
        this.action.isCanceled = true;
    }
    trySetValue(child) {
        const currentTime = this.orchestrationContext.currentUtcDateTime;
        const finalFireTime = this.action.fireAt;
        if (finalFireTime > currentTime) {
            const nextTimer = this.getNextTimerTask(finalFireTime, currentTime);
            this.addNewChild(nextTimer);
        }
        super.trySetValue(child);
    }
    getNextTimerTask(finalFireTime, currentTime) {
        const durationUntilFire = moment.duration(moment(finalFireTime).diff(currentTime));
        const nextFireTime = durationUntilFire > this.maximumTimerDuration
            ? moment(currentTime).add(this.longRunningTimerIntervalDuration).toDate()
            : finalFireTime;
        return new DFTimerTask_1.DFTimerTask(false, new CreateTimerAction_1.CreateTimerAction(nextFireTime));
    }
    addNewChild(childTimer) {
        childTimer.parent = this;
        this.children.push(childTimer);
        this.executor.trackOpenTask(childTimer);
    }
}
exports.LongTimerTask = LongTimerTask;
//# sourceMappingURL=LongTimerTask.js.map