"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DurableOrchestrationContext = void 0;
const WhenAllAction_1 = require("../actions/WhenAllAction");
const WhenAnyAction_1 = require("../actions/WhenAnyAction");
const task_1 = require("../task");
const moment = require("moment");
const ReplaySchema_1 = require("./ReplaySchema");
const SignalEntityAction_1 = require("../actions/SignalEntityAction");
const CallActivityAction_1 = require("../actions/CallActivityAction");
const CallActivityWithRetryAction_1 = require("../actions/CallActivityWithRetryAction");
const CallEntityAction_1 = require("../actions/CallEntityAction");
const CallHttpAction_1 = require("../actions/CallHttpAction");
const CallSubOrchestratorAction_1 = require("../actions/CallSubOrchestratorAction");
const CallSubOrchestratorWithRetryAction_1 = require("../actions/CallSubOrchestratorWithRetryAction");
const ContinueAsNewAction_1 = require("../actions/ContinueAsNewAction");
const CreateTimerAction_1 = require("../actions/CreateTimerAction");
const ExternalEventType_1 = require("../actions/ExternalEventType");
const WaitForExternalEventAction_1 = require("../actions/WaitForExternalEventAction");
const GuidManager_1 = require("../util/GuidManager");
const DurableHttpRequest_1 = require("../http/DurableHttpRequest");
class DurableOrchestrationContext {
    constructor(state, instanceId, currentUtcDateTime, isReplaying, parentInstanceId, longRunningTimerIntervalDuration, maximumShortTimerDuration, defaultHttpAsyncRequestSleepTimeMillseconds, schemaVersion, input, taskOrchestratorExecutor) {
        this.taskOrchestratorExecutor = taskOrchestratorExecutor;
        this.Task = {
            all: (tasks) => {
                if (this.isDFTaskArray(tasks)) {
                    const action = new WhenAllAction_1.WhenAllAction(tasks);
                    const task = new task_1.WhenAllTask(tasks, action);
                    return task;
                }
                throw Error("Task.all received a non-valid input. " +
                    "This may occur if it somehow received a non-list input, " +
                    "or if the input list's Tasks were corrupted. Please review your orchestrator code and/or file an issue.");
            },
            any: (tasks) => {
                if (this.isDFTaskArray(tasks)) {
                    const action = new WhenAnyAction_1.WhenAnyAction(tasks);
                    const task = new task_1.WhenAnyTask(tasks, action);
                    return task;
                }
                throw Error("Task.any received a non-valid input. " +
                    "This may occur if it somehow received a non-list input, " +
                    "or if the input list's Tasks were corrupted. Please review your orchestrator code and/or file an issue.");
            },
        };
        this.state = state;
        this.instanceId = instanceId;
        this.isReplaying = isReplaying;
        this.currentUtcDateTime = currentUtcDateTime;
        this.parentInstanceId = parentInstanceId;
        this.longRunningTimerIntervalDuration = longRunningTimerIntervalDuration
            ? moment.duration(longRunningTimerIntervalDuration)
            : undefined;
        this.maximumShortTimerDuration = maximumShortTimerDuration
            ? moment.duration(maximumShortTimerDuration)
            : undefined;
        this.defaultHttpAsyncRequestSleepTimeMillseconds = defaultHttpAsyncRequestSleepTimeMillseconds;
        this.schemaVersion = schemaVersion;
        this.input = input;
        this.newGuidCounter = 0;
    }
    isDFTaskArray(tasks) {
        return tasks.every((x) => x instanceof task_1.DFTask);
    }
    callActivity(name, input) {
        const newAction = new CallActivityAction_1.CallActivityAction(name, input);
        const task = new task_1.AtomicTask(false, newAction);
        return task;
    }
    callActivityWithRetry(name, retryOptions, input) {
        const newAction = new CallActivityWithRetryAction_1.CallActivityWithRetryAction(name, retryOptions, input);
        const backingTask = new task_1.AtomicTask(false, newAction);
        const task = new task_1.RetryableTask(backingTask, retryOptions);
        return task;
    }
    callEntity(entityId, operationName, operationInput) {
        const newAction = new CallEntityAction_1.CallEntityAction(entityId, operationName, operationInput);
        const task = new task_1.AtomicTask(false, newAction);
        return task;
    }
    signalEntity(entityId, operationName, operationInput) {
        const action = new SignalEntityAction_1.SignalEntityAction(entityId, operationName, operationInput);
        this.taskOrchestratorExecutor.recordFireAndForgetAction(action);
    }
    callSubOrchestrator(name, input, instanceId) {
        if (!name) {
            throw new Error("A sub-orchestration function name must be provided when attempting to create a suborchestration");
        }
        const newAction = new CallSubOrchestratorAction_1.CallSubOrchestratorAction(name, instanceId, input);
        const task = new task_1.AtomicTask(false, newAction);
        return task;
    }
    callSubOrchestratorWithRetry(name, retryOptions, input, instanceId) {
        if (!name) {
            throw new Error("A sub-orchestration function name must be provided when attempting to create a suborchestration");
        }
        const newAction = new CallSubOrchestratorWithRetryAction_1.CallSubOrchestratorWithRetryAction(name, retryOptions, input, instanceId);
        const backingTask = new task_1.AtomicTask(false, newAction);
        const task = new task_1.RetryableTask(backingTask, retryOptions);
        return task;
    }
    callHttp(options) {
        let content = options.body;
        if (content && typeof content !== "string") {
            content = JSON.stringify(content);
        }
        let enablePolling = true;
        if (options.enablePolling !== undefined) {
            enablePolling = options.enablePolling;
        }
        else if (options.asynchronousPatternEnabled !== undefined) {
            enablePolling = options.asynchronousPatternEnabled;
        }
        const request = new DurableHttpRequest_1.DurableHttpRequest(options.method, options.url, content, options.headers, options.tokenSource, enablePolling);
        const newAction = new CallHttpAction_1.CallHttpAction(request);
        if (this.schemaVersion >= ReplaySchema_1.ReplaySchema.V3 && request.asynchronousPatternEnabled) {
            if (!this.defaultHttpAsyncRequestSleepTimeMillseconds) {
                throw Error("A framework-internal error was detected: replay schema version >= V3 is being used, " +
                    "but `defaultHttpAsyncRequestSleepDuration` property is not defined. " +
                    "This is likely an issue with the Durable Functions Extension. " +
                    "Please report this bug here: https://github.com/Azure/azure-functions-durable-js/issues");
            }
            return new task_1.CallHttpWithPollingTask(false, newAction, this, this.taskOrchestratorExecutor, this.defaultHttpAsyncRequestSleepTimeMillseconds);
        }
        return new task_1.AtomicTask(false, newAction);
    }
    continueAsNew(input) {
        const newAction = new ContinueAsNewAction_1.ContinueAsNewAction(input);
        this.taskOrchestratorExecutor.addToActions(newAction);
        this.taskOrchestratorExecutor.willContinueAsNew = true;
    }
    createTimer(fireAt) {
        const timerAction = new CreateTimerAction_1.CreateTimerAction(fireAt);
        const durationUntilFire = moment.duration(moment(fireAt).diff(this.currentUtcDateTime));
        if (this.schemaVersion >= ReplaySchema_1.ReplaySchema.V3) {
            if (!this.maximumShortTimerDuration || !this.longRunningTimerIntervalDuration) {
                throw Error("A framework-internal error was detected: replay schema version >= V3 is being used, " +
                    "but one or more of the properties `maximumShortTimerDuration` and `longRunningTimerIntervalDuration` are not defined. " +
                    "This is likely an issue with the Durable Functions Extension. " +
                    "Please report this bug here: https://github.com/Azure/azure-functions-durable-js/issues\n" +
                    `maximumShortTimerDuration: ${this.maximumShortTimerDuration}\n` +
                    `longRunningTimerIntervalDuration: ${this.longRunningTimerIntervalDuration}`);
            }
            if (durationUntilFire > this.maximumShortTimerDuration) {
                return new task_1.LongTimerTask(false, timerAction, this, this.taskOrchestratorExecutor, this.maximumShortTimerDuration.toISOString(), this.longRunningTimerIntervalDuration.toISOString());
            }
        }
        return new task_1.DFTimerTask(false, timerAction);
    }
    getInput() {
        return this.input;
    }
    newGuid(instanceId) {
        const guidNameValue = `${instanceId}_${this.currentUtcDateTime.valueOf()}_${this.newGuidCounter}`;
        this.newGuidCounter++;
        return GuidManager_1.GuidManager.createDeterministicGuid(GuidManager_1.GuidManager.UrlNamespaceValue, guidNameValue);
    }
    setCustomStatus(customStatusObject) {
        this.customStatus = customStatusObject;
    }
    waitForExternalEvent(name) {
        const newAction = new WaitForExternalEventAction_1.WaitForExternalEventAction(name, ExternalEventType_1.ExternalEventType.ExternalEvent);
        const task = new task_1.AtomicTask(name, newAction);
        return task;
    }
}
exports.DurableOrchestrationContext = DurableOrchestrationContext;
//# sourceMappingURL=DurableOrchestrationContext.js.map